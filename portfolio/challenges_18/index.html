<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title></title>
  <meta content="" name="description">
  <meta content="" name="keywords">
  <link href="/static/img/favicon.png" rel="icon">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">
  <link href="/static/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/static/assets/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="/static/assets/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="/static/assets/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="/static/assets/remixicon/remixicon.css" rel="stylesheet">
  <link href="/static/assets/swiper/swiper-bundle.min.css" rel="stylesheet">
  <script src="https://kit.fontawesome.com/69e2443572.js" crossorigin="anonymous"></script>
  <link href="/static/css/style.css" rel="stylesheet">
  <link href="/pygments.css" rel="stylesheet">
  <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(89602269, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/89602269" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
</head>
<body>
  <main id="main">

<style>
body::before {
	background: #040404 url("/static/img/portfolio/post.jpg");
}
</style>
    <!-- ======= шаблон для поста ======= -->
    <div id="portfolio-details" class="portfolio-details">
      <div class="container">
        <div class="row">
          <div class="col-lg-8">
            <h2 class="portfolio-title">Подборка задач с решениями - 18</h2>
          </div>
          <div class="col-lg-8 portfolio-info">
            <h3></h3>
            <ul>
              <li><strong>Категория</strong>: Python</li>
              <li><strong>Дата публикации</strong>: 2022-01-12</li>
              <li><strong>Посмотреть на сайте</strong>: <a href="https://stepik.org">Stepik</a></li>
            </ul>
            <p>
              <p>Подборка беспощадных заданий от Института биоинформатики (Python курсы на Stepik).</p>
<p><em>Задача 1:</em></p>
<p>Вам дано описание наследования классов в формате JSON.
Описание представляет из себя массив JSON-объектов, которые соответствуют классам. У каждого JSON-объекта есть поле name, которое содержит имя класса, и поле parents, которое содержит список имен прямых предков.</p>
<p>Пример:
[{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]</p>
<p>﻿Эквивалент на Python:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">A:</span>
    <span class="nb">pass</span>

<span class="k">class</span> <span class="n">B</span>(<span class="n">A</span>, <span class="n">C</span>):
    <span class="nb">pass</span>

<span class="k">class</span> <span class="n">C</span>(<span class="n">A</span>):
    <span class="nb">pass</span>
</pre></div>


<p>Гарантируется, что никакой класс не наследуется от себя явно или косвенно, и что никакой класс не наследуется явно от одного класса более одного раза.</p>
<p>Для каждого класса вычислите предком скольких классов он является и выведите эту информацию в следующем формате.</p>
<p>&lt;имя класса&gt; : &lt;количество потомков&gt;</p>
<p>Выводить классы следует в лексикографическом порядке.</p>
<div class="codehilite"><pre><span></span><span class="n">Sample</span> <span class="k">Input</span><span class="p">:</span>

<span class="p">[</span><span class="err">{</span><span class="ss">&quot;name&quot;</span><span class="p">:</span> <span class="ss">&quot;A&quot;</span><span class="p">,</span> <span class="ss">&quot;parents&quot;</span><span class="p">:</span> <span class="p">[]</span><span class="err">}</span><span class="p">,</span> <span class="err">{</span><span class="ss">&quot;name&quot;</span><span class="p">:</span> <span class="ss">&quot;B&quot;</span><span class="p">,</span> <span class="ss">&quot;parents&quot;</span><span class="p">:</span> <span class="p">[</span><span class="ss">&quot;A&quot;</span><span class="p">,</span> <span class="ss">&quot;C&quot;</span><span class="p">]</span><span class="err">}</span><span class="p">,</span> <span class="err">{</span><span class="ss">&quot;name&quot;</span><span class="p">:</span> <span class="ss">&quot;C&quot;</span><span class="p">,</span> <span class="ss">&quot;parents&quot;</span><span class="p">:</span> <span class="p">[</span><span class="ss">&quot;A&quot;</span><span class="p">]</span><span class="err">}</span><span class="p">]</span>

<span class="n">Sample</span> <span class="k">Output</span><span class="p">:</span>

<span class="n">A</span> <span class="p">:</span> <span class="mi">3</span>
<span class="n">B</span> <span class="p">:</span> <span class="mi">1</span>
<span class="k">C</span> <span class="p">:</span> <span class="mi">2</span>
</pre></div>


<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>

<span class="k">def</span> <span class="nf">find_children</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;parents&quot;</span><span class="p">]:</span>
            <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">find_children</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">find_names</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>


<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="n">names</span> <span class="o">=</span> <span class="n">find_names</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{name} : {len(find_children(name, data))}&quot;</span><span class="p">)</span>
</pre></div>


<p><em>Задача 2:</em></p>
<p>Вам дано описание наследования классов в следующем формате.
&lt;имя класса 1&gt; : &lt;имя класса 2&gt; &lt;имя класса 3&gt; ... &lt;имя класса k&gt;
Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.</p>
<p>Или эквивалентно записи:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">Class1</span>(<span class="n">Class2</span>, <span class="n">Class3</span> ... <span class="n">ClassK</span>):
    <span class="nb">pass</span>
</pre></div>


<p>Класс A является прямым предком класса B, если B отнаследован от A:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">B</span>(<span class="n">A</span>):
    <span class="nb">pass</span>
</pre></div>


<p>Класс A является предком класса B, если:</p>
<ul>
<li>A = B;</li>
<li>A - прямой предок B</li>
<li>существует такой класс C, что C - прямой предок B и A - предок C</li>
</ul>
<p>Например:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">B</span>(<span class="n">A</span>):
    <span class="nb">pass</span>

<span class="k">class</span> <span class="n">C</span>(<span class="n">B</span>):
    <span class="nb">pass</span>
</pre></div>


<p>A -- предок С</p>
<p>Вам необходимо отвечать на запросы, является ли один класс предком другого класса</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">def</span> <span class="nv">set_value</span><span class="ss">(</span><span class="nv">value</span>, <span class="nv">d</span><span class="ss">)</span>:
    <span class="k">return</span> <span class="nv">set</span><span class="ss">(</span><span class="nv">sum</span><span class="ss">((</span><span class="nv">list</span><span class="ss">(</span><span class="nv">d</span>[<span class="nv">key</span>]<span class="ss">)</span> <span class="k">for</span> <span class="nv">key</span> <span class="nv">in</span> <span class="nv">value</span> <span class="k">if</span> <span class="nv">key</span> <span class="nv">in</span> <span class="nv">d</span><span class="ss">)</span>, []<span class="ss">))</span>

<span class="nv">d</span> <span class="o">=</span> {}
<span class="k">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">()))</span>:
    <span class="nv">k</span>, <span class="o">*</span><span class="nv">parent</span> <span class="o">=</span> <span class="nv">input</span><span class="ss">()</span>.<span class="nv">split</span><span class="ss">()</span>
    <span class="nv">d</span>[<span class="nv">k</span>] <span class="o">=</span> <span class="nv">set</span><span class="ss">(</span><span class="nv">parent</span>[<span class="mi">1</span>:] <span class="o">+</span> [<span class="nv">k</span>]<span class="ss">)</span>

<span class="nv">d_tmp</span> <span class="o">=</span> {<span class="nv">k</span>: <span class="nv">set_value</span><span class="ss">(</span><span class="nv">v</span>, <span class="nv">d</span><span class="ss">)</span> <span class="o">|</span> <span class="nv">v</span> <span class="k">for</span> <span class="nv">k</span>, <span class="nv">v</span> <span class="nv">in</span> <span class="nv">d</span>.<span class="nv">items</span><span class="ss">()</span>}
<span class="k">while</span> <span class="nv">d_tmp</span> <span class="o">!=</span> <span class="nv">d</span>:
    <span class="nv">d</span> <span class="o">=</span> {<span class="nv">k</span>: <span class="nv">set_value</span><span class="ss">(</span><span class="nv">v</span>, <span class="nv">d_tmp</span><span class="ss">)</span> <span class="o">|</span> <span class="nv">v</span> <span class="k">for</span> <span class="nv">k</span>, <span class="nv">v</span> <span class="nv">in</span> <span class="nv">d_tmp</span>.<span class="nv">items</span><span class="ss">()</span>}
    <span class="nv">d_tmp</span> <span class="o">=</span> {<span class="nv">k</span>: <span class="nv">set_value</span><span class="ss">(</span><span class="nv">v</span>, <span class="nv">d</span><span class="ss">)</span> <span class="o">|</span> <span class="nv">v</span> <span class="k">for</span> <span class="nv">k</span>, <span class="nv">v</span> <span class="nv">in</span> <span class="nv">d</span>.<span class="nv">items</span><span class="ss">()</span>}

<span class="k">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">()))</span>:
    <span class="nv">value</span>, <span class="nv">key</span> <span class="o">=</span> <span class="nv">input</span><span class="ss">()</span>.<span class="nv">split</span><span class="ss">()</span>
    <span class="nv">print</span><span class="ss">(</span><span class="s1">&#39;</span><span class="s">Yes</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="nv">value</span> <span class="nv">in</span> <span class="nv">d</span>[<span class="nv">key</span>] <span class="k">else</span> <span class="s1">&#39;</span><span class="s">No</span><span class="s1">&#39;</span><span class="ss">)</span>
</pre></div>


<p><em>Задача 3:</em></p>
<p>Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать добавление элемента на вершину стека, удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, умножения и целочисленного деления.</p>
<p>Операция сложения на стеке определяется следующим образом. Со стека снимается верхний элемент (top1), затем снимается следующий верхний элемент (top2), и затем как результат операции сложения на вершину стека кладется элемент, равный top1 + top2.</p>
<p>Аналогичным образом определяются операции вычитания (top1 - top2), умножения (top1 * top2) и целочисленного деления (top1 // top2).</p>
<p>Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от стандартного класса list.</p>
<p>Требуемая структура класса:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">ExtendedStack</span>(<span class="n">list</span>):
    <span class="n">def</span> <span class="nb">sum</span>(<span class="k">self</span>):
        <span class="c1"># операция сложения</span>

    <span class="n">def</span> <span class="k">sub</span>(<span class="k">self</span>):
        <span class="c1"># операция вычитания</span>

    <span class="n">def</span> <span class="n">mul</span>(<span class="k">self</span>):
        <span class="c1"># операция умножения</span>

    <span class="n">def</span> <span class="o">div</span>(<span class="k">self</span>):
        <span class="c1"># операция целочисленного деления</span>
</pre></div>


<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">ExtendedStack</span>(<span class="n">list</span>):
    <span class="n">def</span> <span class="nb">sum</span>(<span class="k">self</span>):
        <span class="n">top1</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="n">top2</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="k">self</span>.<span class="n">append</span>(<span class="n">top1</span> + <span class="n">top2</span>)

    <span class="n">def</span> <span class="k">sub</span>(<span class="k">self</span>):
        <span class="n">top1</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="n">top2</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="k">self</span>.<span class="n">append</span>(<span class="n">top1</span> - <span class="n">top2</span>)

    <span class="n">def</span> <span class="n">mul</span>(<span class="k">self</span>):
        <span class="n">top1</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="n">top2</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="k">self</span>.<span class="n">append</span>(<span class="n">top1</span> * <span class="n">top2</span>)

    <span class="n">def</span> <span class="o">div</span>(<span class="k">self</span>):
        <span class="n">top1</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="n">top2</span> = <span class="k">self</span>.<span class="nb">pop</span>()
        <span class="k">self</span>.<span class="n">append</span>(<span class="n">top1</span> // <span class="n">top2</span>)
</pre></div>


<p><em>Задача 4:</em></p>
<p>Одно из применений множественного наследование – расширение функциональности класса каким-то заранее определенным способом. Например, если нам понадобится логировать какую-то информацию при обращении к методам класса.</p>
<p>Рассмотрим класс Loggable:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Loggable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
</pre></div>


<p>У него есть ровно один метод log, который позволяет выводить в лог (в данном случае в stdout) какое-то сообщение, добавляя при этом текущее время.
Реализуйте класс LoggableList, отнаследовав его от классов list и Loggable таким образом, чтобы при добавлении элемента в список посредством метода append в лог отправлялось сообщение, состоящее из только что добавленного элемента.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">LoggableList</span>(<span class="n">list</span>, <span class="n">Loggable</span>):
    <span class="n">def</span> <span class="n">append</span>(<span class="k">self</span>, <span class="o">x</span>):
        <span class="k">self</span>.<span class="nb">log</span>(<span class="o">x</span>)
        <span class="n">super</span>().<span class="n">append</span>(<span class="o">x</span>)
</pre></div>


<p><em>Задача 5:</em></p>
<p>Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.</p>
<p>В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.</p>
<p>Вашей программе на вход подаются следующие запросы:</p>
<ul>
<li>
<p>create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent></p>
</li>
<li>
<p>add <namespace> <var> – добавить в пространство <namespace> переменную <var></p>
</li>
<li>
<p>get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при  запросе из пространства <namespace>, или None, если такого пространства не существует</p>
</li>
</ul>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">namespaces</span> <span class="o">=</span> {<span class="s1">&#39;</span><span class="s">global</span><span class="s1">&#39;</span>:{}}
<span class="nv">variables</span> <span class="o">=</span> {}
<span class="nv">output</span> <span class="o">=</span> []

<span class="nv">def</span> <span class="nv">create_namespace</span><span class="ss">(</span><span class="nv">namespace</span>, <span class="nv">parent</span>, <span class="nv">space</span><span class="o">=</span><span class="nv">namespaces</span><span class="ss">)</span>:
    <span class="k">if</span> <span class="nv">parent</span> <span class="nv">in</span> <span class="nv">space</span>.<span class="nv">keys</span><span class="ss">()</span> <span class="nv">and</span> <span class="nv">len</span><span class="ss">(</span><span class="nv">space</span>[<span class="nv">parent</span>]<span class="ss">)</span> <span class="o">==</span> <span class="mi">0</span>:
        <span class="nv">space</span>[<span class="nv">parent</span>] <span class="o">=</span> [<span class="nv">namespace</span>]
    <span class="nv">elif</span> <span class="nv">parent</span> <span class="nv">in</span> <span class="nv">space</span>.<span class="nv">keys</span><span class="ss">()</span> <span class="nv">and</span> <span class="nv">len</span><span class="ss">(</span><span class="nv">space</span>[<span class="nv">parent</span>]<span class="ss">)</span> <span class="o">&gt;</span> <span class="mi">0</span>:
        <span class="nv">space</span>[<span class="nv">parent</span>].<span class="nv">append</span><span class="ss">(</span><span class="nv">namespace</span><span class="ss">)</span>
    <span class="k">else</span>:
        <span class="nv">space</span>[<span class="nv">parent</span>] <span class="o">=</span> [<span class="nv">namespace</span>]

<span class="nv">def</span> <span class="nv">add_var</span><span class="ss">(</span><span class="nv">namespace</span>, <span class="nv">variable</span><span class="ss">)</span>:
    <span class="k">if</span> <span class="nv">variable</span> <span class="nv">in</span> <span class="nv">variables</span>.<span class="nv">keys</span><span class="ss">()</span>:
        <span class="nv">variables</span>[<span class="nv">variable</span>].<span class="nv">append</span><span class="ss">(</span><span class="nv">namespace</span><span class="ss">)</span>
    <span class="k">else</span>:
        <span class="nv">variables</span>[<span class="nv">variable</span>] <span class="o">=</span> [<span class="nv">namespace</span>]

<span class="nv">def</span> <span class="nv">get_nest</span><span class="ss">(</span><span class="nv">namespace</span><span class="ss">)</span>:
    <span class="k">for</span> <span class="nv">key</span>, <span class="nv">value</span> <span class="nv">in</span> <span class="nv">namespaces</span>.<span class="nv">items</span><span class="ss">()</span>:
        <span class="k">if</span> <span class="nv">namespace</span> <span class="nv">in</span> <span class="nv">value</span>:
            <span class="k">return</span> <span class="nv">key</span>

<span class="nv">def</span> <span class="nv">get_var</span><span class="ss">(</span><span class="nv">namespace</span>, <span class="nv">variable</span>, <span class="nv">space</span><span class="o">=</span><span class="nv">namespaces</span><span class="ss">)</span>:
    <span class="k">if</span> <span class="nv">variable</span> <span class="nv">not</span> <span class="nv">in</span> <span class="nv">variables</span>.<span class="nv">keys</span><span class="ss">()</span>:
        <span class="k">return</span> <span class="nv">None</span>
    <span class="nv">elif</span> <span class="nv">namespace</span> <span class="nv">in</span> <span class="nv">variables</span>[<span class="nv">variable</span>]:
        <span class="k">return</span> <span class="nv">namespace</span>
    <span class="nv">elif</span> <span class="nv">namespace</span> <span class="o">!=</span> <span class="nv">None</span>:
        <span class="k">return</span> <span class="nv">get_var</span><span class="ss">(</span><span class="nv">get_nest</span><span class="ss">(</span><span class="nv">namespace</span><span class="ss">)</span>, <span class="nv">variable</span><span class="ss">)</span>

<span class="k">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">()))</span>:
    <span class="nv">comm</span> <span class="o">=</span> <span class="nv">input</span><span class="ss">()</span>.<span class="nv">split</span><span class="ss">()</span>
    <span class="k">if</span> <span class="s1">&#39;</span><span class="s">create</span><span class="s1">&#39;</span> <span class="nv">in</span> <span class="nv">comm</span>:
        <span class="nv">create_namespace</span><span class="ss">(</span><span class="nv">comm</span>[<span class="mi">1</span>], <span class="nv">comm</span>[<span class="mi">2</span>]<span class="ss">)</span>
    <span class="k">if</span> <span class="s1">&#39;</span><span class="s">add</span><span class="s1">&#39;</span> <span class="nv">in</span> <span class="nv">comm</span>:
        <span class="nv">add_var</span><span class="ss">(</span><span class="nv">comm</span>[<span class="mi">1</span>], <span class="nv">comm</span>[<span class="mi">2</span>]<span class="ss">)</span>
    <span class="k">if</span> <span class="s1">&#39;</span><span class="s">get</span><span class="s1">&#39;</span> <span class="nv">in</span> <span class="nv">comm</span>:
       <span class="nv">output</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">get_var</span><span class="ss">(</span><span class="nv">comm</span>[<span class="mi">1</span>], <span class="nv">comm</span>[<span class="mi">2</span>]<span class="ss">))</span>

<span class="nv">print</span><span class="ss">(</span><span class="o">*</span><span class="nv">output</span>, <span class="nv">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="ss">)</span>
</pre></div>


<p><em>Задача 6:</em></p>
<p>Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.</p>
<p>Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. Выведите количество различных объектов в этом списке.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">ans</span> <span class="o">=</span> []
<span class="k">for</span> <span class="nv">obj</span> <span class="nv">in</span> <span class="nv">objects</span>:
    <span class="k">if</span> <span class="nv">obj</span> <span class="nv">not</span> <span class="nv">in</span> <span class="nv">ans</span>:
        <span class="nv">ans</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">obj</span><span class="ss">)</span>

<span class="nv">print</span><span class="ss">(</span><span class="nv">len</span><span class="ss">(</span><span class="nv">ans</span><span class="ss">))</span>
</pre></div>


<p><em>Задача 7:</em></p>
<p>Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.</p>
<p>Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.</p>
<p>Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.</p>
<p>Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.</p>
<p>Класс должен иметь следующий вид</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">Buffer:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="k">self</span>):
        <span class="c1"># конструктор без аргументов</span>
    
    <span class="n">def</span> <span class="n">add</span>(<span class="k">self</span>, *<span class="n">a</span>):
        <span class="c1"># добавить следующую часть последовательности</span>

    <span class="n">def</span> <span class="n">get_current_part</span>(<span class="k">self</span>):
        <span class="c1"># вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были     </span>
        <span class="c1"># добавлены</span>
</pre></div>


<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">class</span> <span class="nv">Buffer</span>:
    <span class="nv">def</span> <span class="nv">__init__</span><span class="ss">(</span><span class="nv">self</span><span class="ss">)</span>:
        <span class="nv">self</span>.<span class="nv">current</span> <span class="o">=</span> []

    <span class="nv">def</span> <span class="nv">add</span><span class="ss">(</span><span class="nv">self</span>, <span class="o">*</span><span class="nv">a</span><span class="ss">)</span>:
        <span class="nv">self</span>.<span class="nv">current</span>.<span class="nv">extend</span><span class="ss">(</span><span class="nv">a</span><span class="ss">)</span>
        <span class="k">while</span> <span class="nv">len</span><span class="ss">(</span><span class="nv">self</span>.<span class="nv">current</span><span class="ss">)</span> <span class="o">&gt;=</span> <span class="mi">5</span>:
            <span class="nv">temp</span> <span class="o">=</span> []
            <span class="k">for</span> <span class="nv">_</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="mi">5</span><span class="ss">)</span>:
                <span class="nv">temp</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">self</span>.<span class="nv">current</span>.<span class="nv">pop</span><span class="ss">(</span><span class="mi">0</span><span class="ss">))</span>
            <span class="nv">print</span><span class="ss">(</span><span class="nv">sum</span><span class="ss">(</span><span class="nv">temp</span><span class="ss">))</span>


    <span class="nv">def</span> <span class="nv">get_current_part</span><span class="ss">(</span><span class="nv">self</span><span class="ss">)</span>:
        <span class="k">return</span> <span class="nv">self</span>.<span class="nv">current</span>
</pre></div>


<p><em>Задача 8:</em></p>
<p>Реализуйте класс MoneyBox, для работы с виртуальной копилкой.</p>
<p>Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.</p>
<p>Класс должен иметь следующий вид</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="n">MoneyBox:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="k">self</span>, <span class="n">capacity</span>):
        <span class="c1"># конструктор с аргументом – вместимость копилки</span>

    <span class="n">def</span> <span class="n">can_add</span>(<span class="k">self</span>, <span class="n">v</span>):
        <span class="c1"># True, если можно добавить v монет, False иначе</span>

    <span class="n">def</span> <span class="n">add</span>(<span class="k">self</span>, <span class="n">v</span>):
        <span class="c1"># положить v монет в копилку</span>
</pre></div>


<p>При создании копилки, число монет в ней равно 0.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">class</span> <span class="nv">MoneyBox</span>:
    <span class="nv">def</span> <span class="nv">__init__</span><span class="ss">(</span><span class="nv">self</span>, <span class="nv">capacity</span><span class="ss">)</span>:
        <span class="nv">self</span>.<span class="nv">capacity</span> <span class="o">=</span> <span class="nv">capacity</span>
        <span class="nv">self</span>.<span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nv">def</span> <span class="nv">can_add</span><span class="ss">(</span><span class="nv">self</span>, <span class="nv">v</span><span class="ss">)</span>:
        <span class="k">return</span> <span class="nv">self</span>.<span class="nv">count</span> <span class="o">+</span> <span class="nv">v</span> <span class="o">&lt;=</span> <span class="nv">self</span>.<span class="nv">capacity</span>

    <span class="nv">def</span> <span class="nv">add</span><span class="ss">(</span><span class="nv">self</span>, <span class="nv">v</span><span class="ss">)</span>:
        <span class="k">if</span> <span class="nv">self</span>.<span class="nv">can_add</span><span class="ss">(</span><span class="nv">v</span><span class="ss">)</span>:
            <span class="nv">self</span>.<span class="nv">count</span> <span class="o">+=</span> <span class="nv">v</span>
</pre></div>


<p><em>Задача 9:</em></p>
<p>Вам дано описание наследования классов исключений в следующем формате.
&lt;имя исключения 1&gt; : &lt;имя исключения 2&gt; &lt;имя исключения 3&gt; ... &lt;имя исключения k&gt;
Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.</p>
<p>Или эквивалентно записи:</p>
<p>class Error1(Error2, Error3 ... ErrorK):
    pass</p>
<p>Антон написал код, который выглядит следующим образом.</p>
<div class="codehilite"><pre><span></span><span class="k">try</span><span class="o">:</span>
   <span class="n">foo</span><span class="o">()</span>
<span class="n">except</span> <span class="o">&lt;</span><span class="err">имя</span> <span class="mi">1</span><span class="o">&gt;:</span>
   <span class="n">print</span><span class="o">(</span><span class="s2">&quot;&lt;имя 1&gt;&quot;</span><span class="o">)</span>
<span class="n">except</span> <span class="o">&lt;</span><span class="err">имя</span> <span class="mi">2</span><span class="o">&gt;:</span>
   <span class="n">print</span><span class="o">(</span><span class="s2">&quot;&lt;имя 2&gt;&quot;</span><span class="o">)</span>
<span class="o">...</span>
</pre></div>


<p>Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде будет пойман их предок. Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого положения и напишите программу, которая будет определять обработку каких исключений можно удалить из кода.
Важное примечание:
В отличие от предыдущей задачи, типы исключений не созданы.
Создавать классы исключений также не требуется
Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">parents</span> <span class="o">=</span> <span class="nv">dict</span><span class="ss">()</span>

<span class="nv">def</span> <span class="nv">expand</span><span class="ss">(</span><span class="nv">ex</span>: <span class="nv">str</span><span class="ss">)</span> <span class="o">-&gt;</span> <span class="nv">set</span>:
    <span class="nb">result</span> <span class="o">=</span> <span class="nv">set</span><span class="ss">()</span>
    <span class="nb">result</span>.<span class="nv">add</span><span class="ss">(</span><span class="nv">ex</span><span class="ss">)</span>
    <span class="k">if</span> <span class="nv">ex</span> <span class="nv">in</span> <span class="nv">parents</span>:
        <span class="k">for</span> <span class="nv">e</span> <span class="nv">in</span> <span class="nv">parents</span>[<span class="nv">ex</span>]:
            <span class="nb">result</span>.<span class="nv">update</span><span class="ss">(</span><span class="nv">expand</span><span class="ss">(</span><span class="nv">e</span><span class="ss">))</span>   
    <span class="k">return</span> <span class="nb">result</span>

<span class="k">for</span> <span class="nv">_</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">()))</span>:
    <span class="nv">r</span> <span class="o">=</span> <span class="nv">input</span><span class="ss">()</span>.<span class="nv">split</span><span class="ss">()</span>
    <span class="nv">parents</span>[<span class="nv">r</span>[<span class="mi">0</span>]] <span class="o">=</span> <span class="nv">set</span><span class="ss">()</span>
    <span class="k">if</span> <span class="nv">len</span><span class="ss">(</span><span class="nv">r</span><span class="ss">)</span> <span class="o">&gt;</span> <span class="mi">1</span>: 
        <span class="nv">parents</span>[<span class="nv">r</span>[<span class="mi">0</span>]].<span class="nv">update</span><span class="ss">(</span><span class="nv">set</span><span class="ss">(</span><span class="nv">r</span>[<span class="mi">2</span>:]<span class="ss">))</span>

<span class="nv">caught</span> <span class="o">=</span> <span class="nv">set</span><span class="ss">()</span>
<span class="k">for</span> <span class="nv">_</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="nv">int</span><span class="ss">(</span><span class="nv">input</span><span class="ss">()))</span>:
    <span class="nv">ex</span> <span class="o">=</span> <span class="nv">input</span><span class="ss">()</span>
    <span class="k">if</span> <span class="nv">caught</span> <span class="o">&amp;</span> <span class="nv">expand</span><span class="ss">(</span><span class="nv">ex</span><span class="ss">)</span>:
        <span class="nv">print</span><span class="ss">(</span><span class="nv">ex</span><span class="ss">)</span>
    <span class="k">else</span>:
        <span class="nv">caught</span>.<span class="nv">add</span><span class="ss">(</span><span class="nv">ex</span><span class="ss">)</span>
</pre></div>


<p><em>Задача 10:</em></p>
<p>Реализуйте класс PositiveList, отнаследовав его от класса list, для хранения положительных целых чисел.
Также реализуйте новое исключение NonPositiveError.</p>
<p>В классе PositiveList переопределите метод append(self, x) таким образом, чтобы при попытке добавить неположительное целое число бросалось исключение NonPositiveError и число не добавлялось, а при попытке добавить положительное целое число, число добавлялось бы как в стандартный list.</p>
<p>В данной задаче гарантируется, что в качестве аргумента x метода append всегда будет передаваться целое число.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="nv">class</span> <span class="nv">NonPositiveError</span><span class="ss">(</span><span class="nv">Exception</span><span class="ss">)</span>:
    <span class="nv">pass</span>

<span class="nv">class</span> <span class="nv">PositiveList</span><span class="ss">(</span><span class="nv">list</span><span class="ss">)</span>:
    <span class="nv">def</span> <span class="nv">append</span><span class="ss">(</span><span class="nv">self</span>, <span class="nv">x</span><span class="ss">)</span>:
        <span class="k">if</span> <span class="nv">x</span> <span class="o">&gt;</span> <span class="mi">0</span>:
            <span class="nv">super</span><span class="ss">(</span><span class="nv">PositiveList</span>, <span class="nv">self</span><span class="ss">)</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">x</span><span class="ss">)</span>
        <span class="k">else</span>:
            <span class="nv">raise</span> <span class="nv">NonPositiveError</span>
</pre></div>


<p><em>Задача 11:</em></p>
<p><em>Это упрощенный вариант классической сложной задачи об островах. Здесь матрица состоит из 5х5 элементов, однако решение подойдет для массива любого размера - в том числе прямоугольного.</em></p>
<p>Вводится двумерный список размерностью 5 х 5 элементов, состоящий из нулей и, в некоторых позициях, единиц (см. пример ввода ниже). Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. То есть, вокруг каждой единицы должны быть нули. Если проверка проходит вывести ДА, иначе - НЕТ.</p>
<p><em>Решение:</em></p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
<span class="n">num</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">)</span>
<span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">isSafe</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">processed</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">and</span> \
           <span class="n">matrix</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">processed</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
    <span class="n">processed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>

            <span class="k">if</span> <span class="n">isSafe</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">col</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">processed</span><span class="p">):</span>

                <span class="n">processed</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">y</span> <span class="o">+</span> <span class="n">col</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">col</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">countIslands</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>


    <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">processed</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>

    <span class="n">island</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">BFS</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">processed</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">island</span> <span class="o">=</span> <span class="n">island</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">island</span>



<span class="k">print</span><span class="p">(</span><span class="s1">&#39;ДА&#39;</span> <span class="k">if</span> <span class="n">countIslands</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span> <span class="k">else</span> <span class="s1">&#39;НЕТ&#39;</span><span class="p">)</span>
</pre></div>
            </p>
          </div>
        </div>
      </div>
    </div><!-- конец карточки -->
  <!-- конец поста -->

  </main>
  <!-- Скрипты -->
  <script src="/static/assets/purecounter/purecounter.js"></script>
  <script src="/static/assets/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="/static/assets/glightbox/js/glightbox.min.js"></script>
  <script src="/static/assets/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="/static/assets/swiper/swiper-bundle.min.js"></script>
  <script src="/static/assets/waypoints/noframework.waypoints.js"></script>
  <script src="/static/js/main.js"></script>
</body>
</html>